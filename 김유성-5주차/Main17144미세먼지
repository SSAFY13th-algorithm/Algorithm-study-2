package algostudy;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

public class Main17144미세먼지 {

	static int R, C, T;
	static int map[][];
	// 상 하 좌 우
	static int[] dr = { -1, 1, 0, 0 };
	static int[] dc = { 0, 0, -1, 1 };
	
	// 우, 상, 좌, 하
	static int[] air_dr = {0, -1, 0, 1};
	static int[] air_dc = {1, 0, -1, 0};
	
	static List<int[]> airclean = new ArrayList<int[]>();
	static StringTokenizer st;
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

	public static void main(String[] args) throws IOException {
		input();
		while (T-- > 0) {
			dust();
			clean(airclean.get(0)[0], airclean.get(0)[1], 1);
			clean(airclean.get(1)[0], airclean.get(1)[1], 3);
		}
		printResult();
	}
	
	static void printResult() {
		int sum = 0;
		for (int i = 0; i < R; i++) {
			for (int j = 0; j < C; j++) {
				if (map[i][j] > 0)
					sum += map[i][j];
			}
		}
		System.out.println(sum);
	}

	static void input() throws IOException {
		st = new StringTokenizer(br.readLine());
		R = Integer.parseInt(st.nextToken());
		C = Integer.parseInt(st.nextToken());
		T = Integer.parseInt(st.nextToken());

		map = new int[R][C];
		for (int i = 0; i < R; i++) {
			st = new StringTokenizer(br.readLine());
			for (int j = 0; j < C; j++) {
				map[i][j] = Integer.parseInt(st.nextToken());
				if (map[i][j] == -1) {
					airclean.add(new int[] {i, j}); // 0이 위, 1이 아래
				}
			}
		}
	}

	static void dust() {
		int[][] d = new int[R][C];

		for (int i = 0; i < R; i++) {
			for (int j = 0; j < C; j++) {
				moveDust(i, j, d);
			}
		}
		
		for (int i = 0; i < R; i++) {
			for (int j = 0; j < C; j++) {
				map[i][j] += d[i][j]; // 변화된 먼지의 양
			}
		}
		
		
	}

	static void moveDust(int r, int c, int[][] d) {
		int nr, nc, count = 0;
		int val = map[r][c];
		
		if(val < 5) // 먼지양이 5보다 작으면 변화가 없다.
			return;

		for (int i = 0; i < 4; i++) {
			nr = r + dr[i];
			nc = c + dc[i];
			if (checkArea(nr, nc) && map[nr][nc] != -1) {
				d[nr][nc] += val / 5;
				count++;
			}
		}
		map[r][c] -= (val / 5) * count;
	}

	/*
	 * 공청기는 위쪽은 우, 상, 좌, 하로 이동하고 아래쪽은 우, 하, 좌, 상으로 이동한다.
	 * 이를 하나의 함수로 처리해주기 위해서 위쪽은 방향이 바뀔 때 dir_add로 1을 더하고 4의 나머지로 처리하면 0, 1, 2, 3
	 * 아래쪽은 방향이 바뀔 때 dir_add로 3을 더하고 4의 나머지로 처리하면 0, 3, 2, 1 아 된다. 그러면 하나의 함수로 처리가 가능하다.
	 */
	static void clean(int r, int c, int dir_add) { 
		int dir = 0;
		int nr, nc, before = 0;
		
		while (true) {
			nr = r + air_dr[dir];
			nc = c + air_dc[dir];
			if (checkArea(nr, nc)) {
				if (map[r][c] == -1) { // 맨 처음에 공기가 나갈때는 0으로 만들어 줘야 함. 
					before = map[nr][nc];
					map[nr][nc] = 0;
				} else if(map[nr][nc] == -1){ // 공청기로 돌아왔을 때
					return;
				} else {
					int temp = before;
					before = map[nr][nc];
					map[nr][nc] = temp;
				}
				r = nr;
				c = nc;
			} else {
				dir = (dir + dir_add) % 4; // 방향만 전환해준다.
			}
		}
	}
	
	static boolean checkArea(int r, int c) {
		if (r >= 0 && c >= 0 && r < R && c < C)
			return true;
		return false;
	}

}
