import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.List;
import java.util.StringTokenizer;

public class Main16498작은벌점 {

	static int[] ABC = new int[3];
	static List<Integer> cardA = new LinkedList<>();
	static List<Integer> cardB = new LinkedList<>();;
	static List<Integer> cardC = new LinkedList<>();;

	static int min = Integer.MAX_VALUE;
	static int max = Integer.MIN_VALUE;
	static int score = Integer.MAX_VALUE;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());

		ABC[0] = Integer.parseInt(st.nextToken());
		ABC[1] = Integer.parseInt(st.nextToken());
		ABC[2] = Integer.parseInt(st.nextToken());

		for (int cycle = 0; cycle < 3; cycle++) {
			st = new StringTokenizer(br.readLine());
			for (int i = 0; i < ABC[cycle]; i++) {
				int input = Integer.parseInt(st.nextToken());
				switch (cycle) {
				case 0: {
					cardA.add(input);
					break;
				}
				case 1: {
					cardB.add(input);
					break;
				}
				case 2: {
					cardC.add(input);
					break;
				}
				}
			}
		}
		// 이분탐색 하려면 정렬해야됨
		cardA.sort((a, b) -> a - b);
		cardB.sort((a, b) -> a - b);
		cardC.sort((a, b) -> a - b);
		
		for (int i = 0; i < cardA.size(); i++) {
			int a = cardA.get(i);
			int b = binarySearch(cardB, a);
			int c = binarySearch(cardC, a);
			// a != b일 때 a랑 가까운 값이랑 b랑 가까운 값 중 하나를 택해야 한다.
			int d = binarySearch(cardC, b);

			max = Math.max(Math.max(a, b), c);
			min = Math.min(Math.min(a, b), c);
			score = Math.min(score, Math.abs(max - min));
			
			max = Math.max(Math.max(a, b), d);
			min = Math.min(Math.min(a, b), d);
			score = Math.min(score, Math.abs(max - min));
			if (score == 0) {
				System.out.println(0);
				return;
			}
				
		}
		System.out.println(score);

	}

	static int binarySearch(List<Integer> arr, int num) {
		int start = 0;
		int end = arr.size() - 1;
		int mid, get_num;
		int ret = Integer.MAX_VALUE; // num으로 들어온 값과 가장 가까운 값을 저장. num이 6일 때 [1, 4, 10]에서 return값은 10 이지만 4가 더 가까운 수이다.
		
		while (start <= end) {
			mid = (start + end) / 2;
			get_num = arr.get(mid);
			if (get_num < num) {
				start = mid + 1;
			} else if (get_num > num) {
				end = mid - 1;
			} else { // get_num == num
				return num;
			}
			// num과의 차이가 더 적게 나는 값으로 갱신
			if (Math.abs(num - ret) >= Math.abs(num - get_num)) {
				ret = get_num;
			}
		}
		return ret;
	}
}
